# 大麦项目笔记——业务功能

## 分库分表

关键：选择好**分片键**，减少**全路由**情况

### 一般做法

大部分分库分表就是通过**常用字段**进行分库分表，比如**id**，或者是program库中的seat表通过**强相关的programId**去分表。

### 特殊分片键

#### 1. 附属表

额外维护了user_phone和user_email表，原因：

用户登录的时候用的是手机号或者邮箱，但是如果我们没有额外维护这两张表，则用户进行信息查询的时候会发生全路由。

目前采取的做法是：通过手机号/邮箱查询userId，然后拿着userId去查询userInfo，这样虽然会发生两次查询，但是都不会产生全路由，效率会比直接全路由查询要高

#### 2. 基因法+雪花算法改造

使用基因法对orderId进行改造，原因：

我们希望通过userId和orderId两种方式进行订单查询，但是分片键只能有一个，根据基因法，我们可以对orderId进行改造。

基因法：

```bash
32 = 100000
31 % 32 = 11111(5个1 也就是32取log2次数)
如果把任意一个数x的后五位改造成11111，那么x%32 = 11111
```

因此我们对雪花算法进行改造：

![分布式唯一ID生成：雪花算法的原理及实战使用、三大问题的解决_雪花算法使用-CSDN博客](./images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ2hhcnRl,size_20,color_FFFFFF,t_70,g_se,x_16.png)

把orderId后面的**序列号**改成是 **userId % 分表数量** 的值。

这样一来，我们进行表查询的时候，只需要拿到**userId/orderId**，然后对**分表数量取模**就行。就能快速定位到表。

进行数据库查询稍微麻烦一点，不能直接使用取模（之前创建orderId是根据表数量来的）。不过也是利用了相同的**基因**，对**分库数	量取模也相同**的性质。进行数据库快速定位

思考：这样的设计会不会产生问题？

原因：**基因替换破坏了原本的序列号**，这个序列号的作用是在时间戳和机器ID相同的情况下作为标识的，会不会导致无法区分orderId

答：是在**本业务中不会有问题**，因为本业务的基因法替换是**创建order**的时候进行的，41位时间戳的长度有精确到了毫秒，因此**冲突	的场景是同一个用户在同一毫秒的时间内创建了多个order**，对于正常的业务而言，这显然是不可能的。

## 业务功能

### 用户服务

#### 1. 预热购票人信息

因为进行购票的时候是高并发，因此即使购票人信息表是通过userId取查询的不会引发全路由也不应该直接查询数据库。应从缓存查询。

查询条件：

1. 时机：抢票首先要进入到节目详情页面，因此可以在**查看节目详情**的时候执行preload逻辑。

2. 用户条件：只有**已登陆**的用户才能进行查询，不登陆无法抢票，无需查询。
3. 节目条件：只有**热门节目**才需要查询，防止内存占用。

思考：会不会有数据库缓存不一致问题？
答：本业务**不会**有数据库缓存不一致问题，因为**查看购票人信息是基于userId**的，也就**没有并发修改**的情况。如果需要修改信息，那么就采取常规做法，先**写数据库再删缓存**即可。

除非出现极端情况，用户同时在不同客户端进行操作。

