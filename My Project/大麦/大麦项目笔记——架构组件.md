# 大麦项目笔记——组件架构

## 参数加密和签名

在网关模块中，为了保证后端系统安全性，会对前端请求进行签名认证。

格式：

1. 同一采用POST请求，因为需要搭载属性
2. 如果不跳过验证，则body中一定要有以下字段
   1. code：平台码，不同的平台标识，用于让后端区分加解密算法
   2. businsessBody：业务参数
   3. sin：签名

通过请求头`no_verify = true`、`encrypt = v1/v2`关闭/开启参数校验

### V1版本

V1版本采用的是把**code和businessBody结合进行签名，签名放到sign中**。验签的时候，通过code查找对应的公钥，然后进行校验。

### V2版本

V2版本相比V1多了一层加密，也就是前端传给后端参数的业务参数也进行加密了，sign的加密不变。

也就是后端在进行签名校验之前得到的**businessBody参数也是密文**，需要先对business进行解密，然后拿到明文business才能对sign进行验签



## 链路追踪

市场上常用的链路追踪工具是SkyWalking，研究了一下，他是通过字节码增强生成代理类，然后本地内存进行数据汇总，接着使用gRPC传输到控制台中。

项目中的链路不会特别长，最多也就是4层，于是我决定自己搭建一个简单的链路追踪方案。

主要考虑的方向：

1. 唯一性：链路Id一定是唯一的，应该通过UUID或者结合时间戳等方式进行生成
2. 传播机制：链路Id需要随着请求一起传递，通常是通过头部实现，通过AOP每次从请求中读取，处理完毕后再加入到下游服务请求的头部中
3. 轻量级：不希望对性能损耗太大
4. 可以实现监控收集和展示：可视化界面更加直观，不需要到处找

### 实现方案

在（Nginx/Gateway）中生traceId，然后在后续的请求中传递，同时利用AOP把traceId提前放到MDC中，这样每次执行请求的时候就能打印traceId了

### 问题1：Feign的传递

默认的Feign不会把A服务的请求头中的内容添加到B服务的请求头中，但是这个相对好解决，只需要通过在为spring-cloud-frameword的component中继承`RequestInterceptor`进行改造即可，然后再通过自动装配引入到feign的调用模块，Spring在使用feign调用的时候就遍历所有注册的RequestInterceptor，然后执行自定义方法了。

### 问题2：线程池调用

我们使用的MDC和BaseParameterHolder本质上都是ThreadLocal，也就是作用域只在本线程，那么父子线程之间的传递就是得考虑的地方（比如异步预热用户购票人信息）

1. 单纯传递RequestAttributes的弊端：如果开启了异步线程，且子线程运行比较耗时，这时候如果父线程已经结束运行了，则拿不到RequestAttributes

2. 考虑阿里的TransmittableThreadLocal可以解决问题，但是会比较重，因为我们只有个别参数需要传递，因此可以考虑自己对核心部分进行改造

   通过wrapTask进行改造，取得父线程的上下文信息，然后放到子进程中，再利用finally还原子线程的上下文信息

   ![image-20250106111749265](./images/image-20250106111749265.png)

   



