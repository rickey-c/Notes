# 大麦项目笔记——组件架构

## 参数加密和签名

在网关模块中，为了保证后端系统安全性，会对前端请求进行签名认证。

格式：

1. 同一采用POST请求，因为需要搭载属性
2. 如果不跳过验证，则body中一定要有以下字段
   1. code：平台码，不同的平台标识，用于让后端区分加解密算法
   2. businsessBody：业务参数
   3. sin：签名

通过请求头`no_verify = true`、`encrypt = v1/v2`关闭/开启参数校验

### V1版本

V1版本采用的是把**code和businessBody结合进行签名，签名放到sign中**。验签的时候，通过code查找对应的公钥，然后进行校验。

### V2版本

V2版本相比V1多了一层加密，也就是前端传给后端参数的业务参数也进行加密了，sign的加密不变。

也就是后端在进行签名校验之前得到的**businessBody参数也是密文**，需要先对business进行解密，然后拿到明文business才能对sign进行验签



## 链路追踪

市场上常用的链路追踪工具是SkyWalking，研究了一下，他是通过字节码增强生成代理类，然后本地内存进行数据汇总，接着使用gRPC传输到控制台中。

项目中的链路不会特别长，最多也就是4层，于是我决定自己搭建一个简单的链路追踪方案。

主要考虑的方向：

1. 唯一性：链路Id一定是唯一的，应该通过UUID或者结合时间戳等方式进行生成
2. 传播机制：链路Id需要随着请求一起传递，通常是通过头部实现，通过AOP每次从请求中读取，处理完毕后再加入到下游服务请求的头部中
3. 轻量级：不希望对性能损耗太大
4. 可以实现监控收集和展示：可视化界面更加直观，不需要到处找

### 实现方案

在（Nginx/Gateway）中生traceId，然后在后续的请求中传递，同时利用AOP把traceId提前放到MDC中，这样每次执行请求的时候就能打印traceId了

### 问题1：Feign的传递

默认的Feign不会把A服务的请求头中的内容添加到B服务的请求头中，但是这个相对好解决，只需要通过在为spring-cloud-frameword的component中继承`RequestInterceptor`进行改造即可，然后再通过自动装配引入到feign的调用模块，Spring在使用feign调用的时候就遍历所有注册的RequestInterceptor，然后执行自定义方法了。

### 问题2：线程池调用

我们使用的MDC和BaseParameterHolder本质上都是ThreadLocal，也就是作用域只在本线程，那么父子线程之间的传递就是得考虑的地方（比如异步预热用户购票人信息）

1. 单纯传递RequestAttributes的弊端：如果开启了异步线程，且子线程运行比较耗时，这时候如果父线程已经结束运行了，则拿不到RequestAttributes

2. 考虑阿里的TransmittableThreadLocal可以解决问题，但是会比较重，因为我们只有个别参数需要传递，因此可以考虑自己对核心部分进行改造

   通过wrapTask进行改造，取得父线程的上下文信息，然后放到子进程中，再利用finally还原子线程的上下文信息

   ![image-20250106111749265](./images/image-20250106111749265.png)

   

## 统一服务初始化操作

为了统一服务初始化，首先需要了解SpringBean初始化顺序

### SpringBean初始化接口

```java
// 1.InitializingBean的afterPropertiesSet执行
@Component
public class TestInitializingBean implements InitializingBean {
    
    @Override
    public void afterPropertiesSet() {
        System.out.println("======afterPropertiesSet执行======");
    }
}


// 2.postConstruct执行
@Component
public class TestPostConstruct {
    
    @PostConstruct
    public void postConstruct(){
        System.out.println("======postConstruct执行======");
    }
}

// 3.ApplicationEventListener执行
@Component
public class TestEventListener implements ApplicationListener<ApplicationStartedEvent> {
    
    @Override
    public void onApplicationEvent(ApplicationStartedEvent event) {
        System.out.println("======ApplicationStartedEvent执行======");
    }
}

// 4.CommandLineRunner使用run执行
@Component
public class TestCommandLineRunner implements CommandLineRunner {
    
    @Override
    public void run(final String... args) {
        System.out.println("======run执行======");
    }
}

// 先后顺序:
// ======afterPropertiesSet执行======
// ======postConstruct执行======
// ======ApplicationStartedEvent执行======
// ======run执行======

// 简单理解就是先inizialingBean的afterPropertiesSet，然后PostConstruct，然后ApplicationStartedEvent，最后才是run接口
```

### 自定义Bean初始化顺序

当然，我们可以通过@Order注解执行Bean初始化顺序，但是一旦自定义的组件多了之后，Order不便于维护，于是可以考虑自定义初始化，这样能够明确我们某个组件用的是什么方式初始化，在这个方式的初始化过程中的顺序是怎么样的

初始化组件结构：

![未命名绘图.drawio](./images/未命名绘图.drawio.png)

`InitializeHandler`初始化顶级接口，定义了type，excutorOrder，executeInit三个接口，其中type通过四种初始化抽象类指定，具体的执行顺序和执行逻辑由具体实现类实现

```java
public interface InitializeHandler {
    /**
     * 初始化执行 类型
     * @return 类型
     * */
    String type();
    
    /**
     * 执行顺序
     * @return 顺序
     * */
    Integer executeOrder();
    
    /**
     * 执行逻辑
     * @param context 容器上下文
     * */
    void executeInit(ConfigurableApplicationContext context);
    
}
```

具体初始化还是借助Spring容器的初始化手段，通过excute包下定义的方法实现的，比如下面是Initialing Bean实现类

```java
public class ApplicationInitializingBeanExecute extends AbstractApplicationExecute implements InitializingBean {
    
    public ApplicationInitializingBeanExecute(ConfigurableApplicationContext applicationContext){
        super(applicationContext);
    }
    
    @Override
    public void afterPropertiesSet() {
        execute();
    }
    
    @Override
    public String type() {
        return APPLICATION_INITIALIZING_BEAN;
    }
}

@AllArgsConstructor
public abstract class AbstractApplicationExecute {
    
    private final ConfigurableApplicationContext applicationContext;
    
    public void execute(){
        Map<String, InitializeHandler> initializeHandlerMap = applicationContext.getBeansOfType(InitializeHandler.class);
        initializeHandlerMap.values()
                .stream()
                .filter(initializeHandler -> initializeHandler.type().equals(type()))
                .sorted(Comparator.comparingInt(InitializeHandler::executeOrder))
                .forEach(initializeHandler -> {
                    initializeHandler.executeInit(applicationContext);
                });
    }
    /**
     * 初始化执行 类型
     * @return 类型
     * */
    public abstract String type();
}
```

借助Spring进行初始化，但是具体细节我们通过applicationContext获取到Bean的方法实现，然后执行初始化类型比较和排序，最后执行初始化方法。

实现之后，Bean的初始化顺序会很方便进行跟踪，只要看实现类继承了对应四种抽象类，实现的接口排序顺序是什么样的，初始化是进行什么操作可以一目了然。

## 组合模式解决参数校验

### 组合容器初始化

初始化类，继承了监听应用启动的组件，也就是**在服务初始化的时候会进行初始化，后续需要使用的时候直接就可以用了**

```java
// 执行组合容器初始化工作
@AllArgsConstructor
public class CompositeInit extends AbstractApplicationStartEventListenerHandler {

    /**
     * 组合容器
     */
    private final CompositeContainer compositeContainer;
    
    @Override
    public Integer executeOrder() {
        return 1;
    }

    /**
     * 进行组合容器初始化
     * @param context 容器上下文
     */
    @Override
    public void executeInit(ConfigurableApplicationContext context) {
        compositeContainer.init(context);
    }
}
```

**具体初始化过程：**

首先执行随着应用启动和CompositeInit调用CompositeContainer的init()方法，进行初始化

1. 加载AbstractComposite的Bean
2. 然后根据type分组
3. 接着调用build()构建树结构
4. 最后返回`Map<type,CompositeTree>`结构的树

```java
public class CompositeContainer<T> {
    
    private final Map<String, AbstractComposite> allCompositeInterfaceMap = new HashMap<>();

    /**
     * 初始化构建树结构
     * */
    public void init(ConfigurableApplicationContext applicationEvent){
        // 获取所有 AbstractComposite 类型的 Bean
        Map<String, AbstractComposite> compositeInterfaceMap = applicationEvent.getBeansOfType(AbstractComposite.class);
        // 查找出AbstractComposite类型，然后根据type进行分组
        Map<String, List<AbstractComposite>> collect = compositeInterfaceMap.values().stream().collect(Collectors.groupingBy(AbstractComposite::type));
        collect.forEach((k,v) -> {
            // 构建组件树结构
            AbstractComposite root = build(v);
            // 如果根节点存在，则执行业务逻辑
            if (Objects.nonNull(root)) {
                allCompositeInterfaceMap.put(k, root);
            }
        });
    }

    /**
     * 执行树中的节点
     * */
    public void execute(String type,T param){
        AbstractComposite compositeInterface = Optional.ofNullable(allCompositeInterfaceMap.get(type))
                .orElseThrow(() -> new DaMaiFrameException(BaseCode.COMPOSITE_NOT_EXIST));
        compositeInterface.allExecute(param);
    }    
    
    
    /**
     * 构建组件树的辅助方法。
     * @param groupedByTier 按层级组织的组件映射。
     * @param currentTier 当前处理的层级。
     */
    private static void buildTree(Map<Integer, Map<Integer, AbstractComposite>> groupedByTier, int currentTier) {
        Map<Integer, AbstractComposite> currentLevelComponents = groupedByTier.get(currentTier);
        Map<Integer, AbstractComposite> nextLevelComponents = groupedByTier.get(currentTier + 1);
        
        if (currentLevelComponents == null) {
            // 当前层级没有组件时，直接返回
            return;
        }
        
        if (nextLevelComponents != null) {
            for (AbstractComposite child : nextLevelComponents.values()) {
                Integer parentOrder = child.executeParentOrder();
                if (parentOrder == null || parentOrder == 0) {
                    // 跳过根节点
                    continue;
                }
                AbstractComposite parent = currentLevelComponents.get(parentOrder);
                if (parent != null) {
                    // 将子节点添加到父节点的子列表中
                    parent.add(child);
                }
            }
        }
        
        // 递归构建下一层级的树结构
        buildTree(groupedByTier, currentTier + 1);
    }
    
    /**
     * 根据提供的组件集合构建组件树，并返回根节点。
     * @param components 组件集合。
     * @return 根节点。
     */
    private static AbstractComposite build(Collection<AbstractComposite> components) {
        // 按层级和执行顺序组织组件
        Map<Integer, Map<Integer, AbstractComposite>> groupedByTier = new TreeMap<>();
        
        for (AbstractComposite component : components) {
            groupedByTier.computeIfAbsent(component.executeTier(), k -> new HashMap<>(16))
                    // 使用 executeOrder 作为键
                    .put(component.executeOrder(), component);
        }
        
        // 找到最小层级
        Integer minTier = groupedByTier.keySet().stream().min(Integer::compare).orElse(null);
        if (minTier == null) {
            // 没有组件时返回空
            return null;
        }
        
        // 构建组件树
        buildTree(groupedByTier, minTier);
        
        // 找到并返回根节点
        return groupedByTier.get(minTier).values().stream()
                .filter(c -> c.executeParentOrder() == null || c.executeParentOrder() == 0)
                .findFirst()
                .orElse(null);
    }
}
```

树结构：

![image-20250106145528635](./images/image-20250106145528635.png)

### 组合容器使用

用户注册参数校验组合树：

![image-20250106152755220](./images/image-20250106152755220.png)

类结构：

![image-20250106152858882](./images/image-20250106152858882.png)

比如说我现在的用户注册需要进行三种参数校验

1. 图形验证码校验
2. 当前短期注册并发量校验（如果现在系统压力过大就不予注册）
3. 用户是否已经注册校验

```java
public abstract class AbstractUserRegisterCheckHandler extends AbstractComposite<UserRegisterDto> {
    
    @Override
    public String type() {
        return CompositeCheckType.USER_REGISTER_CHECK.getValue();
    }
}
```

那就先创建一个`AbstractUserRegisterCheckHandler`继承`AbstractComposite<UserRegisterDto>`，规定类型，然后再用三个具体的`参数校验Handler`继承`AbstractUserRegisterCheckHandler`，定义具体的excute方法和树结构的顺序

以`UserExistCheckHandler`为例：

```java
@Component
public class UserExistCheckHandler extends AbstractUserRegisterCheckHandler {

    @Autowired
    private UserService userService;
    
    @Override
    public void execute(final UserRegisterDto userRegisterDto) {
        userService.doExist(userRegisterDto.getMobile());
    }
    
    @Override
    public Integer executeParentOrder() {
        return 1;
    }
    
    @Override
    public Integer executeTier() {
        return 2;
    }

    @Override
    public Integer executeOrder() {
        return 2;
    }
}
```

### 组合容器执行校验

实际上执行就是使用了二叉树层序遍历进行执行校验

```java
    /**
     * 按层次结构执行每个组件的业务逻辑
     * @param param 泛型参数，用于业务执行
     */
    public void allExecute(T param) {
        Queue<AbstractComposite<T>> queue = new LinkedList<>();
        
        queue.add(this); 
        
        while (!queue.isEmpty()) {
           
            int levelSize = queue.size(); 
            
            for (int i = 0; i < levelSize; i++) {
               
                AbstractComposite<T> current = queue.poll(); 
                
                
                assert current != null;
                current.execute(param);
                
                queue.addAll(current.list);
            }
        }
    }
```

## 图形验证码

